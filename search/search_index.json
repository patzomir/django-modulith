{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Djnago Modulith","text":"<p>A toolkit for building modular, maintainable Django applications using the Modulith architectural pattern.</p>"},{"location":"#what-is-a-modulith","title":"What is a Modulith?","text":"<p>A Modulith is a monolithic application that is internally structured as a collection of well-defined, loosely-coupled modules. It combines the deployment simplicity of a monolith with the architectural clarity of microservices.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Module Generation: Quickly scaffold new application modules with proper structure</li> <li>Interface Registry: Define clear boundaries between modules via the interface registry</li> <li>Import Control: Enforce architectural boundaries using import linting</li> <li>Django Integration: Seamlessly works with Django's existing patterns</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install django-modulith\n</code></pre> <p>Add to your Django project's INSTALLED_APPS:</p> <pre><code>INSTALLED_APPS = [\n    # ...\n    'django_modulith',\n    # ...\n]\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<ol> <li>Create a new module This will:</li> </ol> <p>Create a new module directory with proper structure Update the importlinter configuration to include the new module</p> <ol> <li>Define module interfaces in <code>modulith.py</code>:</li> </ol> <pre><code># modulith.py\nfrom django_modulith.interface_decorator import interface\n\n@interface\ndef get_user_profile(user_id: int) -&gt; dict:\n    # Implementation here\n    pass\n</code></pre> <ol> <li>Use module interfaces</li> </ol> <pre><code># some_module.py\nfrom django_modulith.interface_registry import InterfaceRegistry\n\nuser_profile = InterfaceRegistry.get_user_profile(user_id=1)\n</code></pre>"},{"location":"#architecture-enforcement","title":"Architecture Enforcement","text":"<p>The library helps enforce module boundaries through import linting:</p> <pre><code># Check for import rule violations\npython -m importlinter\n\n# Generate visualization of module dependencies\npython -m importlinter.visualization\n</code></pre>"},{"location":"#interface-registry","title":"Interface Registry","text":"<p>The <code>InterfaceRegistry</code> serves as the core of the inter-module communication:</p> <ul> <li>Functions registered with the <code>@interface</code> decorator become available via the registry</li> <li>Type annotations are preserved for IDE autocomplete support</li> <li>The registry pattern discourages direct imports between modules</li> </ul>"},{"location":"#best-practices","title":"Best Practices","text":"<ol> <li>Keep modules focused: Each module should have a single responsibility</li> <li>Use interfaces: Access other modules through the interface registry, not direct imports</li> <li>Honor boundaries: Structure code to respect the architectural boundaries</li> <li>Document interfaces: Well-documented interfaces make the module boundaries clear</li> </ol>"},{"location":"#configuration","title":"Configuration","text":"<p>Import Linter Configuration The <code>.importlinter</code> file controls module boundaries:</p> <pre><code>[importlinter]\nroot_package = modules\ninclude_external_packages = n\n\n[importlinter:contract:modulith_modules]\nname = Domain modules are independent\ntype = independence\nmodules = \n    users\n    products\n    orders\n</code></pre>"},{"location":"#advanced-usage","title":"Advanced Usage","text":""},{"location":"#type-hints","title":"Type Hints","text":"<p>A stub file (interface_registry.pyi) is automatically generated to provide proper type hints for registered interfaces.</p>"},{"location":"#example-using-the-interface-registry","title":"Example: Using the Interface Registry","text":""},{"location":"#step-1-register-an-interface-in-modulithpy","title":"Step 1: Register an Interface in <code>modulith.py</code>","text":"<p>In the <code>users</code> module, define and register an interface in <code>modulith.py</code>:</p> <pre><code># users/modulith.py\nfrom django_modulith.interface_decorator import interface\n\n@interface\ndef get_user_profile(user_id: int) -&gt; dict:\n    # Implementation here\n    pass\n</code></pre>"},{"location":"#step-2-use-the-registered-interface-in-another-module","title":"Step 2: Use the Registered Interface in Another Module","text":"<p>In the <code>profiles</code> module, use the registered interface via the registry:</p> <pre><code># profiles/some_module.py\nfrom django_modulith.interface_registry import InterfaceRegistry\n\nuser_profile = InterfaceRegistry.get_user_profile(user_id=1)\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please check the contribution guidelines for more details.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#django_modulith.interface_registry","title":"<code>django_modulith.interface_registry</code>","text":""},{"location":"reference/#django_modulith.interface_registry.InterfaceRegistry","title":"<code>InterfaceRegistry</code>","text":"<p>Registry that dynamically adds interfaces as actual methods</p> Source code in <code>src/django_modulith/interface_registry.py</code> <pre><code>class InterfaceRegistry:\n    \"\"\"Registry that dynamically adds interfaces as actual methods\"\"\"\n\n    _registered_interfaces: Set[str] = (\n        set()\n    )  # Track registered names to prevent overrides\n\n    @classmethod\n    def register(cls, func: Callable, name: str):\n        \"\"\"Register a function dynamically as a method on the class\"\"\"\n        if name in cls._registered_interfaces:\n            raise ValueError(\n                f\"interface '{name}' is already registered. Choose a unique name.\"\n            )\n\n        setattr(cls, name, classmethod(func))\n        cls._registered_interfaces.add(name)\n\n    @classmethod\n    def list_interfaces(cls) -&gt; Set[str]:\n        \"\"\"List all registered interfaces\"\"\"\n        return cls._registered_interfaces\n</code></pre>"},{"location":"reference/#django_modulith.interface_registry.InterfaceRegistry.list_interfaces","title":"<code>list_interfaces()</code>  <code>classmethod</code>","text":"<p>List all registered interfaces</p> Source code in <code>src/django_modulith/interface_registry.py</code> <pre><code>@classmethod\ndef list_interfaces(cls) -&gt; Set[str]:\n    \"\"\"List all registered interfaces\"\"\"\n    return cls._registered_interfaces\n</code></pre>"},{"location":"reference/#django_modulith.interface_registry.InterfaceRegistry.register","title":"<code>register(func, name)</code>  <code>classmethod</code>","text":"<p>Register a function dynamically as a method on the class</p> Source code in <code>src/django_modulith/interface_registry.py</code> <pre><code>@classmethod\ndef register(cls, func: Callable, name: str):\n    \"\"\"Register a function dynamically as a method on the class\"\"\"\n    if name in cls._registered_interfaces:\n        raise ValueError(\n            f\"interface '{name}' is already registered. Choose a unique name.\"\n        )\n\n    setattr(cls, name, classmethod(func))\n    cls._registered_interfaces.add(name)\n</code></pre>"},{"location":"reference/#django_modulith.interface_decorator","title":"<code>django_modulith.interface_decorator</code>","text":""},{"location":"reference/#django_modulith.interface_decorator.interface","title":"<code>interface(name=None)</code>","text":"<p>Decorator that can be used with or without parameters</p> Usage <p>@interface def my_function(): ...</p> <p>@interface() def my_function(): ...</p> <p>@interface(\"custom_name\") def my_function(): ...</p> Source code in <code>src/django_modulith/interface_decorator.py</code> <pre><code>def interface(\n    name: Optional[Union[str, T]] = None,\n) -&gt; Union[Callable[[T], T], T]:\n    \"\"\"Decorator that can be used with or without parameters\n\n    Usage:\n        @interface\n        def my_function(): ...\n\n        @interface()\n        def my_function(): ...\n\n        @interface(\"custom_name\")\n        def my_function(): ...\n    \"\"\"\n    func_or_name = name\n\n    def decorator(func: T) -&gt; T:\n        service_name = (\n            func.__name__\n            if isinstance(func_or_name, (type(None), Callable))\n            else func_or_name\n        )\n        InterfaceRegistry.register(func, str(service_name))\n\n        @wraps(func)\n        def wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n            return func(*args, **kwargs)\n\n        return cast(T, wrapper)\n\n    # Handle both @interface and @interface() cases\n    if isinstance(func_or_name, Callable):\n        return decorator(func_or_name)\n\n    # Handle @interface(\"name\") case\n    return decorator\n</code></pre>"},{"location":"reference/#django_modulith.management.commands.generatestubs","title":"<code>django_modulith.management.commands.generatestubs</code>","text":""},{"location":"reference/#django_modulith.management.commands.generatestubs.Command","title":"<code>Command</code>","text":"<p>             Bases: <code>BaseCommand</code></p> Source code in <code>src/django_modulith/management/commands/generatestubs.py</code> <pre><code>class Command(BaseCommand):\n    help = (\n        \"Generate interface stubs by scanning all installed apps for modulith.py files\"\n    )\n\n    def handle(self, *args, **options):\n        # Find and import all modulith.py files\n        self.stdout.write(\"Scanning installed apps for modulith.py files...\")\n        modules_found = self._find_and_import_modulith_files()\n\n        if not modules_found:\n            self.stdout.write(\n                self.style.WARNING(\"No modulith.py files found in installed apps.\")\n            )\n        else:\n            self.stdout.write(f\"Found {len(modules_found)} modulith.py files.\")\n\n        # Generate stubs\n        self.stdout.write(\"Generating interface stubs...\")\n        # Default to the package directory\n        package_dir = Path(__file__).parent.parent.parent\n        output_path = package_dir / \"interface_registry.pyi\"\n\n        stub_content = self._generate_stubs()\n\n        # Ensure the directory exists\n        output_path.parent.mkdir(parents=True, exist_ok=True)\n\n        # Write the stub file\n        output_path.write_text(stub_content)\n\n        self.stdout.write(\n            self.style.SUCCESS(f\"Interface stubs generated at {output_path}\")\n        )\n\n    def _find_and_import_modulith_files(self) -&gt; List[str]:\n        \"\"\"Find and import all modulith.py files in installed apps.\"\"\"\n        modules_found = []\n\n        for app_config in apps.get_app_configs():\n            app_path = Path(app_config.path)\n            modulith_file = app_path / \"modulith.py\"\n\n            if modulith_file.exists():\n                module_name = f\"{app_config.name}.modulith\"\n                self.stdout.write(f\"Found {module_name} at {modulith_file}\")\n\n                try:\n                    importlib.import_module(module_name)\n                    modules_found.append(module_name)\n                except Exception as e:\n                    self.stdout.write(\n                        self.style.ERROR(f\"Error importing {module_name}: {e}\")\n                    )\n                    raise CommandError(f\"Error importing {module_name}: {e}\")\n\n        return modules_found\n\n    def _clean_signature(self, signature):\n        \"\"\"Clean up the signature string by removing ~ from type annotations\"\"\"\n        return str(signature).replace(\"~\", \"\")\n\n    def _extract_typevars(self, signatures):\n        \"\"\"Extract TypeVar definitions from signatures\"\"\"\n        typevar_pattern = r\"([A-Z]_co|[A-Z]_contra|[A-Z])\"\n        typevars = set()\n\n        for sig in signatures:\n            # Look for capital letter followed by _co, _contra or just capital letter alone\n            matches = re.findall(typevar_pattern, str(sig))\n            typevars.update(matches)\n\n        # Generate TypeVar definitions\n        typevar_defs = []\n        for tv in sorted(typevars):\n            if tv.endswith(\"_co\"):\n                base = tv[:-3]\n                typevar_defs.append(f\"{tv} = TypeVar('{base}', covariant=True)\")\n            elif tv.endswith(\"_contra\"):\n                base = tv[:-7]\n                typevar_defs.append(f\"{tv} = TypeVar('{base}', contravariant=True)\")\n            else:\n                typevar_defs.append(f\"{tv} = TypeVar('{tv}')\")\n\n        return typevar_defs\n\n    def _generate_stubs(self) -&gt; str:\n        \"\"\"Generate stub file content for InterfaceRegistry\"\"\"\n        # Collect all signatures first to extract TypeVars\n        signatures = []\n\n        # Get signatures from built-in methods\n        for _, method in inspect.getmembers(\n            InterfaceRegistry, predicate=inspect.ismethod\n        ):\n            signatures.append(inspect.signature(method))\n\n        # Get signatures from registered methods\n        for name in InterfaceRegistry.list_interfaces():\n            method = getattr(InterfaceRegistry, name)\n            signatures.append(inspect.signature(method))\n\n        # Extract TypeVars from signatures\n        typevar_defs = self._extract_typevars(signatures)\n\n        # Start building stubs\n        stubs = [\n            \"from typing import Any, Callable, Set, ClassVar, List, TypeVar\\n\",\n        ]\n\n        # Add TypeVar definitions if found\n        if typevar_defs:\n            stubs.append(\"\\n\")\n            for tv_def in typevar_defs:\n                stubs.append(f\"{tv_def}\\n\")\n\n        stubs.extend(\n            [\n                \"\\n\",\n                \"class InterfaceRegistry:\\n\",\n                \"    _registered_interfaces: ClassVar[Set[str]]\\n\",\n                \"\\n\",\n            ]\n        )\n\n        # Add built-in class methods first\n        for name, method in inspect.getmembers(\n            InterfaceRegistry, predicate=inspect.ismethod\n        ):\n            if not name.startswith(\"_\") or name == \"__init__\":\n                signature = inspect.signature(method)\n                clean_sig = self._clean_signature(signature)\n                stub_line = \"    @classmethod\\n\"\n                stub_line += f\"    def {name}{clean_sig}: ...\\n\"\n                stubs.append(stub_line)\n\n        # Add dynamically registered methods\n        for name in InterfaceRegistry.list_interfaces():\n            # Skip if already added (in case list_interfaces itself is registered)\n            if any(f\"def {name}\" in line for line in stubs):\n                continue\n\n            method = getattr(InterfaceRegistry, name)\n            signature = inspect.signature(method)\n            clean_sig = self._clean_signature(signature)\n            stub_line = \"    @classmethod\\n\"\n            stub_line += f\"    def {name}{clean_sig}: ...\\n\"\n            stubs.append(stub_line)\n\n        return \"\".join(stubs)\n</code></pre>"},{"location":"reference/#django_modulith.management.commands.modulith","title":"<code>django_modulith.management.commands.modulith</code>","text":""},{"location":"reference/#django_modulith.management.commands.modulith.Command","title":"<code>Command</code>","text":"<p>             Bases: <code>Command</code></p> Source code in <code>src/django_modulith/management/commands/modulith.py</code> <pre><code>class Command(StartAppCommand):\n    help = f\"Add a new module to the {IMPORTLINTER_FILE} configuration\"\n    contract_key = \"importlinter:contract:modulith_modules\"\n\n    def handle(self, *args, **options):\n        super().handle(*args, **options)\n        config_path = IMPORTLINTER_FILE\n        config = configparser.ConfigParser()\n\n        # Initialize or read existing config\n        if os.path.exists(config_path):\n            config.read(config_path)\n        else:\n            self._initialize_config(config)\n\n        module_name = options[\"name\"]\n        self._add_module_to_config(config, module_name)\n\n        # Write configuration back to file\n        with open(config_path, \"w\") as f:\n            config.write(f)\n\n        self.stdout.write(\n            self.style.SUCCESS(f\"\u2705 {IMPORTLINTER_FILE} updated successfully!\")\n        )\n\n    def _initialize_config(self, config):\n        \"\"\"Initialize a basic importlinter configuration\"\"\"\n        config[\"importlinter\"] = {\n            \"root_package\": \"modules\",\n            \"include_external_packages\": \"n\",\n        }\n\n        config[self.contract_key] = {\n            \"name\": \"Domain modules are independent\",\n            \"type\": \"independence\",\n            \"modules\": \"\",\n        }\n\n        self.stdout.write(\n            self.style.SUCCESS(\"Created initial importlinter configuration\")\n        )\n\n    def _add_module_to_config(self, config, module_name):\n        \"\"\"Add a new module to the modules independence contract\"\"\"\n        if self.contract_key not in config:\n            self.stdout.write(\n                self.style.ERROR(\"Modules contract section not found in config\")\n            )\n            return\n\n        contract_section = config[self.contract_key]\n        modules = contract_section.get(\"modules\", \"\")\n\n        # Add the new module if it's not already there\n        module_list = [m.strip() for m in modules.split(\"\\n\") if m.strip()]\n        if module_name not in module_list:\n            module_list.append(module_name)\n            contract_section[\"modules\"] = \"\\n\".join(module_list)\n            self.stdout.write(\n                f\"Added module '{module_name}' to importlinter configuration\"\n            )\n        else:\n            self.stdout.write(f\"Module '{module_name}' already in configuration\")\n</code></pre>"}]}